// Copyright (c) Microsoft Corporation
// All rights reserved

namespace Microsoft.VisualStudio.Text.Formatting
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Windows.Media;
    using System.Windows.Media.TextFormatting;

    using Microsoft.VisualStudio.Text;

    /// <summary>
    /// Generates formatted line from text snapshots.
    /// </summary>
    public interface IFormattedLineSource
    {
        /// <summary>
        /// Gets the top text snapshot for which this source will provide formatted text.
        /// </summary>
        ITextSnapshot TopTextSnapshot { get; }

        /// <summary>
        /// Gets the source text snapshot for which this source will provide formatted text.
        /// </summary>
        ITextSnapshot SourceTextSnapshot { get; }

        /// <summary>
        /// Gets the <see cref="ITextAndAdornmentSequencer"/> used by this source.
        /// </summary>
        ITextAndAdornmentSequencer TextAndAdornmentSequencer { get; }

        /// <summary>
        /// Gets the number of spaces between each tab stop.
        /// </summary>
        int TabSize { get; }

        /// <summary>
        /// Gets the width of a column in pixels.
        /// </summary>
        /// <remarks>This is used to determine the location of tab stops.</remarks>
        double ColumnWidth { get; }

        /// <summary>
        /// Gets the nominal height of a line.
        /// </summary>
        /// <remarks>
        /// This will not, in general, be the same as TextHeightAboveBaseline + TextHeightBelowBaseline since there is might be some padding between
        /// lines.</remarks>
        double LineHeight { get; }

        /// <summary>
        /// Gets the nominal height of the text above the baseline.
        /// </summary>
        double TextHeightAboveBaseline { get; }

        /// <summary>
        /// Gets the nominal height of the text below the baseline.
        /// </summary>
        double TextHeightBelowBaseline { get; }

        /// <summary>
        /// Gets the base indentation (in logical pixels) for all lines generated by this source.
        /// </summary>
        /// <remarks>
        /// This is generally a small value like 2.0, so that some characters (such as an italic slash) will not be clipped
        /// by the left edge of the view.
        /// </remarks>
        double BaseIndentation { get; }

        /// <summary>
        /// Gets the width (in logical pixels) where the formatted text will be broken into multiple lines. 
        /// </summary>
        /// <remarks>The value 0.0 means that lines should never be broken.</remarks>
        double WordWrapWidth { get; }

        /// <summary>
        /// Gets the maximum auto-indent for wrapped lines.
        /// </summary>
        /// <remarks>
        /// If a long line is word-wrapped, then all the line fragments after the first will be indented by 
        /// the amount of leading white space on the first line, or MaxAutoIndent, whichever is smaller.
        /// </remarks>
        double MaxAutoIndent { get; }

        /// <summary>
        /// True if the formatter uses WPF Display TextFormattingMode, false otherwise.
        /// </summary>
        bool UseDisplayMode { get; }

        /// <summary>
        /// Gets the <see cref="TextRunProperties"/> used to render unclassified text.
        /// </summary>
        TextRunProperties DefaultTextProperties { get; }

        /// <summary>
        /// Formats the text and adornments in a <see cref="ITextSnapshotLine"/>.
        /// </summary>
        /// <param name="visualLine">The line to format.</param>
        /// <returns>The formatted text for that line.</returns>
        /// <remarks>
        /// <para>
        /// <see cref="IFormattedLine"/> objects are <see cref="IDisposable"/>. The caller must explicitly call Dispose() on the returned lines when they are
        /// done with them.
        /// </para>
        /// <para>
        /// The supplied <see cref="ITextSnapshotLine"/> must belong to the snapshot of the visual buffer, since visuals 
        /// live on that buffer.
        /// </para>
        /// </remarks>
        Collection<IFormattedLine> FormatLineInVisualBuffer(ITextSnapshotLine visualLine);
    }
}
